<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Testing With Dependency Injection</title><link rel=stylesheet href=/jdoro-blog/css/main.css></head><body class="bg-gray-50 text-gray-900 min-h-screen flex flex-col dark:bg-gray-900 dark:text-gray-100"><header class="bg-white shadow mb-8 dark:bg-gray-800 dark:shadow-lg"><div class="container mx-auto px-4 py-6 flex items-center justify-between"><a href=/jdoro-blog/ class="text-3xl font-bold text-blue-600 hover:text-blue-800 transition
dark:text-blue-400
dark:hover:text-blue-200">JDORO.println</a>
<button id=dark-toggle class="ml-4 px-3 py-1 rounded bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100 focus:outline-none transition">
<span id=dark-toggle-text>üåô Dark</span></button></div></header><main class="flex-1 container mx-auto px-4 py-8 bg-white rounded-lg shadow-md dark:bg-gray-800 dark:shadow-lg"><div class="max-w-2xl mx-auto py-8 px-4"><article class="prose prose-slate dark:prose-invert"><h1 class="text-3xl font-bold mb-4 dark:text-gray-100">Testing With Dependency Injection</h1><div class="flex items-center text-gray-500 text-sm space-x-4 mb-8 dark:text-gray-400"><span>May 2, 2024</span></div><p>Dependency injection (DI) is a software design pattern that might sound complex,
but it&rsquo;s a powerful tool for writing cleaner, more maintainable code. At its core,
DI is about separating the creation of an object from its usage. This might seem
like a minor detail, but it has significant benefits, especially when it comes
to testing.</p><h3 id=why-use-dependency-injection>Why Use Dependency Injection?</h3><p>There are several reasons to embrace DI, but let&rsquo;s focus on two key advantages:</p><ol><li><p><strong>Loose Coupling:</strong> By separating object creation, DI loosens the coupling
between classes. This means a class doesn&rsquo;t rely on the specific implementation
details of its dependencies. This makes code more flexible and easier to modify.</p></li><li><p><strong>Improved Testability:</strong> When a class tightly couples itself to its
dependencies (like a database connection), testing becomes cumbersome. DI
allows you to inject mock objects during testing, isolating the class&rsquo;s logic
and making unit tests faster and more reliable.</p></li></ol><h3 id=testing-with-mocks-a-java-example>Testing with Mocks: A Java Example</h3><p>Let&rsquo;s see how DI simplifies testing with a practical example in Java. Imagine a
class <code>OrderProcessor</code> that fulfills orders and relies on a <code>PaymentGateway</code> to
process payments. Here&rsquo;s a traditional, tightly coupled approach:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderProcessor</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> PaymentGateway paymentGateway;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>OrderProcessor</span>(PaymentGateway paymentGateway) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>paymentGateway</span> <span style=color:#f92672>=</span> paymentGateway;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processOrder</span>(Order order) <span style=color:#66d9ef>throws</span> PaymentException {
</span></span><span style=display:flex><span>    paymentGateway.<span style=color:#a6e22e>processPayment</span>(order.<span style=color:#a6e22e>getAmount</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... fulfill order logic</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Testing <code>OrderProcessor</code> requires a real <code>PaymentGateway</code> which might be slow or
inconvenient for unit tests. Here&rsquo;s how DI can help:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>PaymentGateway</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processPayment</span>(<span style=color:#66d9ef>double</span> amount) <span style=color:#66d9ef>throws</span> PaymentException;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderProcessor</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> PaymentGateway paymentGateway;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>OrderProcessor</span>(PaymentGateway paymentGateway) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>paymentGateway</span> <span style=color:#f92672>=</span> paymentGateway;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processOrder</span>(Order order) <span style=color:#66d9ef>throws</span> PaymentException {
</span></span><span style=display:flex><span>    paymentGateway.<span style=color:#a6e22e>processPayment</span>(order.<span style=color:#a6e22e>getAmount</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... fulfill order logic</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By defining an interface <code>PaymentGateway</code>, we decouple <code>OrderProcessor</code> from the
concrete implementation. Now, during testing, we can inject a mock object that
simulates the payment gateway&rsquo;s behavior:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderProcessorTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testProcessOrder</span>() <span style=color:#66d9ef>throws</span> PaymentException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a mock PaymentGateway that always succeeds</span>
</span></span><span style=display:flex><span>    PaymentGateway mockGateway <span style=color:#f92672>=</span> Mockito.<span style=color:#a6e22e>mock</span>(PaymentGateway.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>    Mockito.<span style=color:#a6e22e>when</span>(mockGateway.<span style=color:#a6e22e>processPayment</span>(anyDouble())).<span style=color:#a6e22e>thenReturn</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Inject the mock into OrderProcessor</span>
</span></span><span style=display:flex><span>    OrderProcessor processor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> OrderProcessor(mockGateway);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a test order</span>
</span></span><span style=display:flex><span>    Order order <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Order(100.<span style=color:#a6e22e>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    processor.<span style=color:#a6e22e>processOrder</span>(order);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Verify that processPayment was called on the mock</span>
</span></span><span style=display:flex><span>    Mockito.<span style=color:#a6e22e>verify</span>(mockGateway).<span style=color:#a6e22e>processPayment</span>(order.<span style=color:#a6e22e>getAmount</span>());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This test verifies <code>OrderProcessor</code>&rsquo;s logic without relying on an actual payment
gateway. DI makes unit testing faster, more isolated, and ultimately leads to
more robust code.</p><h3 id=beyond-testing-benefits-galore>Beyond Testing: Benefits Galore</h3><p>While testing is a major advantage, DI offers more:</p><ul><li><strong>Increased Reusability:</strong> Decoupled components are easier to reuse in
different contexts.</li><li><strong>Improved Maintainability:</strong> Code becomes easier to modify and refactor when
dependencies are explicit.</li><li><strong>Flexibility:</strong> DI allows you to switch between different implementations of
a dependency easily.</li></ul><p>Dependency injection might seem like an extra layer of complexity at first, but
the benefits in terms of cleaner code, easier testing, and overall
maintainability make it a worthwhile investment for any Java developer. By
embracing DI, you&rsquo;ll write more robust and adaptable software applications.</p></article></div></main><footer class="mt-8 py-6 text-center text-gray-500 text-sm dark:text-gray-400">&copy; 2025 JDORO.println. Powered by <a href=https://gohugo.io/ class="text-blue-500 hover:underline dark:text-blue-300 dark:hover:text-blue-100">Hugo</a>.</footer><script>const body=document.documentElement,toggle=document.getElementById("dark-toggle"),toggleText=document.getElementById("dark-toggle-text");(localStorage.getItem("theme")==="dark"||!localStorage.getItem("theme")&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&(body.classList.add("dark"),toggleText&&(toggleText.textContent="‚òÄÔ∏è Light")),toggle.addEventListener("click",()=>{console.log("toggle"),body.classList.toggle("dark"),body.classList.contains("dark")?(localStorage.setItem("theme","dark"),toggleText.textContent="‚òÄÔ∏è Light"):(localStorage.setItem("theme","light"),toggleText.textContent="üåô Dark")})</script></body></html>