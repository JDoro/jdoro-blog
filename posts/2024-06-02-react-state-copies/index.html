<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>React Best Practices: There can only be one… copy of the state</title><link rel=stylesheet href=/css/main.css></head><body class="bg-gray-50 text-gray-900 min-h-screen flex flex-col dark:bg-gray-900 dark:text-gray-100"><header class="bg-white shadow mb-8 dark:bg-gray-800 dark:shadow-lg"><div class="container mx-auto px-4 py-6 flex items-center justify-between"><a href=/ class="text-3xl font-bold text-blue-600 hover:text-blue-800 transition
dark:text-blue-400
dark:hover:text-blue-200">JDORO.println</a>
<button id=dark-toggle class="ml-4 px-3 py-1 rounded bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100 focus:outline-none transition">
<span id=dark-toggle-text>🌙 Dark</span></button></div></header><main class="flex-1 container mx-auto px-4 py-8 bg-white rounded-lg shadow-md dark:bg-gray-800 dark:shadow-lg"><div class="max-w-2xl mx-auto py-8 px-4"><article class="prose prose-slate dark:prose-invert"><h1 class="text-3xl font-bold mb-4 dark:text-gray-100">React Best Practices: There can only be one… copy of the state</h1><div class="flex items-center text-gray-500 text-sm space-x-4 mb-8 dark:text-gray-400"><span>Jun 2, 2024</span></div><p>In React, state is what makes our components dynamic and responsive. It allows
us to hold onto data that can change over time, triggering UI updates when
needed. However, a common pitfall new React developers encounter is creating
multiple copies of the same state when they need to transform the data slightly
or derive new values from the data.</p><p><strong>Imagine you&rsquo;re building a product listing page.</strong> You have a state variable
holding an array of products, each with a <code>price</code> property. You want to display
both the original price and a discounted price (say, 20% off).</p><p>An initial solution might be to create a copy of the product array within the
component, iterate through it, and calculate the discounted price for each
product. This seems reasonable at first, but as your application grows and you
test more edge cases, you might encounter issues.</p><p>Here&rsquo;s an example of this initial approach:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProductList</span>({<span style=color:#a6e22e>products</span>}) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>discountedProducts</span>, <span style=color:#a6e22e>setDiscountedProducts</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>([]); <span style=color:#75715e>// Create a copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>newDiscountedProducts</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>products</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>product</span>) =&gt; ({
</span></span><span style=display:flex><span>      ...<span style=color:#a6e22e>product</span>, <span style=color:#75715e>// Spread operator to copy product details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>discountedPrice</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.8</span>,
</span></span><span style=display:flex><span>    }));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setDiscountedProducts</span>(<span style=color:#a6e22e>newDiscountedProducts</span>);
</span></span><span style=display:flex><span>  }, [<span style=color:#a6e22e>products</span>]); <span style=color:#75715e>// Update copy whenever products change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>        {<span style=color:#a6e22e>discountedProducts</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>product</span>) =&gt; (
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>li</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>id</span>}&gt;
</span></span><span style=display:flex><span>              {<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>name</span>} <span style=color:#f92672>-</span> <span style=color:#a6e22e>Price</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>$</span>{<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>price</span>} (<span style=color:#a6e22e>Discounted</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>$</span>{<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>discountedPrice</span>})
</span></span><span style=display:flex><span>            &lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        ))}
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this code:</p><ol><li>We create a new state variable <code>discountedProducts</code> to hold the copied array
with discounted prices.</li><li>We use <code>useEffect</code> to listen for changes in the original <code>products</code> state.</li><li>Inside <code>useEffect</code>, we iterate through the original products, calculate the
discounted price for each, and create a new array with these modified
objects.</li><li>Finally, we update the <code>discountedProducts</code> state with the newly created
array.</li></ol><p>This approach works, but as mentioned earlier, it can lead to inconsistencies if
the original state is modified elsewhere without updating the copy.</p><p>There are better ways to handle data transformations without the overhead of
managing multiple state copies. Here&rsquo;s how to approach it:</p><h2 id=simple-transformations-in-variables>Simple Transformations in Variables:</h2><p>If the transformation you need to perform on your state is straightforward,
there&rsquo;s no need to create a separate copy. Instead, consider using a simple
variable within the component itself. This keeps the code clean and easy to
follow, and in most cases, it has minimal impact on performance.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProductCard</span>({<span style=color:#a6e22e>product</span>}) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>discountedPrice</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.8</span>; <span style=color:#75715e>// Simple transformation in a variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>h2</span>&gt;{<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>name</span>}&lt;/<span style=color:#f92672>h2</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>Price</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>$</span>{<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>price</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>p</span>&gt;<span style=color:#a6e22e>Discounted</span> <span style=color:#a6e22e>Price</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>$</span>{<span style=color:#a6e22e>discountedPrice</span>}&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, we calculate the discounted price within the component using a
variable. This avoids the need for a separate state copy and keeps the logic
clear.</p><h2 id=complex-transformations-with-usememo>Complex Transformations with <code>useMemo</code>:</h2><p>For more complex transformations, React offers the <code>useMemo</code> hook. This hook
lets you memoize the result of a function based on its inputs. Memoization
essentially means storing the function&rsquo;s output for a specific set of input
values. If the function is called again with the same inputs, the stored result
is returned instead of re-running the function.</p><p><code>useMemo</code> can be incredibly helpful for optimizing performance in React
applications, especially when dealing with
complex data transformations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>useMemo</span>} <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProductList</span>({<span style=color:#a6e22e>products</span>}) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>filteredProducts</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>products</span>.<span style=color:#a6e22e>filter</span>((<span style=color:#a6e22e>product</span>) =&gt; <span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>inStock</span>);
</span></span><span style=display:flex><span>  }, [<span style=color:#a6e22e>products</span>]); <span style=color:#75715e>// Dependency array ensures recalculation only when products change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>        {<span style=color:#a6e22e>filteredProducts</span>.<span style=color:#a6e22e>map</span>((<span style=color:#a6e22e>product</span>) =&gt; (
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>ProductCard</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>id</span>} <span style=color:#a6e22e>product</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>product</span>}/&gt;
</span></span><span style=display:flex><span>        ))}
</span></span><span style=display:flex><span>      &lt;/<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, we&rsquo;re using <code>useMemo</code> to filter the product list based on the <code>inStock</code>
property. As long as the <code>products</code> array
itself doesn&rsquo;t change, <code>useMemo</code> will ensure the filtered list is only
recalculated when necessary. This can
significantly improve performance, especially when dealing with large datasets.</p><h2 id=important-considerations>Important Considerations:</h2><p>While <code>useMemo</code> is a powerful tool, it&rsquo;s important to remember that it can also
add some memory overhead. Using it
excessively or with large, complex functions might not be the best approach.
Always consider the trade-off between
performance optimization and memory usage.</p><h2 id=conclusion>Conclusion:</h2><p>By avoiding unnecessary state copies and utilizing variables for simple
transformations, and leveraging <code>useMemo</code> for
complex scenarios, you can keep your React state management clean and efficient.
These practices will lead to more
maintainable and performant applications as your React projects grow in
complexity.</p></article></div></main><footer class="mt-8 py-6 text-center text-gray-500 text-sm dark:text-gray-400">&copy; 2025 JDORO.println. Powered by <a href=https://gohugo.io/ class="text-blue-500 hover:underline dark:text-blue-300 dark:hover:text-blue-100">Hugo</a>.</footer><script>const body=document.documentElement,toggle=document.getElementById("dark-toggle"),toggleText=document.getElementById("dark-toggle-text");(localStorage.getItem("theme")==="dark"||!localStorage.getItem("theme")&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&(body.classList.add("dark"),toggleText&&(toggleText.textContent="☀️ Light")),toggle.addEventListener("click",()=>{console.log("toggle"),body.classList.toggle("dark"),body.classList.contains("dark")?(localStorage.setItem("theme","dark"),toggleText.textContent="☀️ Light"):(localStorage.setItem("theme","light"),toggleText.textContent="🌙 Dark")})</script></body></html>