<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>React Best Practices: Minimizing Side Effects in Your React Components</title><link rel=stylesheet href=jdoro-blog//css/main.css></head><body class="bg-gray-50 text-gray-900 min-h-screen flex flex-col dark:bg-gray-900 dark:text-gray-100"><header class="bg-white shadow mb-8 dark:bg-gray-800 dark:shadow-lg"><div class="container mx-auto px-4 py-6 flex items-center justify-between"><a href=jdoro-blog/ class="text-3xl font-bold text-blue-600 hover:text-blue-800 transition
dark:text-blue-400
dark:hover:text-blue-200">JDORO.println</a>
<button id=dark-toggle class="ml-4 px-3 py-1 rounded bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100 focus:outline-none transition">
<span id=dark-toggle-text>üåô Dark</span></button></div></header><main class="flex-1 container mx-auto px-4 py-8 bg-white rounded-lg shadow-md dark:bg-gray-800 dark:shadow-lg"><div class="max-w-2xl mx-auto py-8 px-4"><article class="prose prose-slate dark:prose-invert"><h1 class="text-3xl font-bold mb-4 dark:text-gray-100">React Best Practices: Minimizing Side Effects in Your React Components</h1><div class="flex items-center text-gray-500 text-sm space-x-4 mb-8 dark:text-gray-400"><span>Apr 27, 2024</span></div><p>While the <code>useEffect</code> hook is a powerful tool in React&rsquo;s arsenal, it requires
careful handling to avoid unintended consequences. It allows us to control
side effects that need to be handled at different points within the React
lifecycle. This post explores common anti-patterns with <code>useEffect</code> and
emphasizes keeping your components lean and state updates controlled.</p><h3 id=why-less-useeffect-is-often-more>Why Less <code>useEffect</code> is Often More</h3><p>React components render based on their state. By minimizing the use of
<code>useEffect</code> for side effects, you achieve a cleaner separation of concerns and
potentially improve performance:</p><ul><li><strong>Reduced Complexity:</strong> Fewer <code>useEffect</code> hooks mean less code to manage,
improving maintainability and reducing the risk of unintended interactions
between effects.</li><li><strong>Performance Optimization:</strong> Excessive <code>useEffect</code> calls can trigger
unnecessary re-renders. Keeping them focused ensures efficient component updates.</li></ul><h3 id=state-updates-tread-carefully>State Updates: Tread Carefully</h3><p>While <code>useEffect</code> can be used for state updates, it&rsquo;s generally recommended to
leverage the core <code>useState</code> hook. This keeps your state management logic
centralized and predictable.</p><p>Here&rsquo;s an example of an anti-pattern:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MyComponent</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Simulate some async operation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>setTimeout</span>(() =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>  }, []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>You</span> <span style=color:#a6e22e>clicked</span> {<span style=color:#a6e22e>count</span>} <span style=color:#a6e22e>times</span>
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This code updates the <code>count</code> state within <code>useEffect</code>. A better approach would be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>MyComponent</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>count</span>, <span style=color:#a6e22e>setCount</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleClick</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setCount</span>(<span style=color:#a6e22e>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Simulate some async operation after the click
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>handleClick</span>, <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>  }, []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>handleClick</span>}&gt;<span style=color:#a6e22e>Click</span> <span style=color:#a6e22e>me</span>&lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>You</span> <span style=color:#a6e22e>clicked</span> {<span style=color:#a6e22e>count</span>} <span style=color:#a6e22e>times</span>
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Here, the state update is handled by a separate click handler, keeping <code>useEffect</code>
focused on managing side effects.</p><h3 id=alternatives-to-useeffect>Alternatives to <code>useEffect</code></h3><p>Consider these approaches to minimize <code>useEffect</code> usage:</p><ul><li><strong>Derived State:</strong> Use the <code>useState</code> updater function to access previous state
values, eliminating the need for an effect to calculate derived state.</li><li><strong>Memoization:</strong> For expensive computations that depend on props, leverage
<code>useMemo</code> to cache the result and avoid unnecessary re-calculations.</li></ul><p>By following these principles, you can write cleaner, more performant React
components with a focus on state management through <code>useState</code>. Remember,
<code>useEffect</code> is your friend for side effects, but use it judiciously!</p></article></div></main><footer class="mt-8 py-6 text-center text-gray-500 text-sm dark:text-gray-400">&copy; 2025 JDORO.println. Powered by <a href=https://gohugo.io/ class="text-blue-500 hover:underline dark:text-blue-300 dark:hover:text-blue-100">Hugo</a>.</footer><script>const body=document.documentElement,toggle=document.getElementById("dark-toggle"),toggleText=document.getElementById("dark-toggle-text");(localStorage.getItem("theme")==="dark"||!localStorage.getItem("theme")&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&(body.classList.add("dark"),toggleText&&(toggleText.textContent="‚òÄÔ∏è Light")),toggle.addEventListener("click",()=>{console.log("toggle"),body.classList.toggle("dark"),body.classList.contains("dark")?(localStorage.setItem("theme","dark"),toggleText.textContent="‚òÄÔ∏è Light"):(localStorage.setItem("theme","light"),toggleText.textContent="üåô Dark")})</script></body></html>